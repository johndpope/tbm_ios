 - Handle uploads of multiple videos simultaneously in the background.
 - Multiple uploads in a row for same friend.
   - Save the latest upload task for each friend with its status. 
   - A way to identify upload tasks.
   

- Architecture
  - Upload manager.
    - Tags upload tasks with friend ids.
    - Produces the correct headers. 
  - Handles task events
    - Changes video status on friend object
  - Schedules retries.
  
 - Upload for friend
   x Cancel any running upload task for that friend. Should probably do this so that we dont have an issue with overwriting the output file while it is being accessed.
   x Create a task.
      x Put the body with the body headers in a file for the task.
      x Add the friendId to the description for the new task. 
   x Resume it. 

  - Retry Architecture
    - Exponential holdoff from 10seconds up to 2 minutes then retry every 2 minutes.
    - Save retry count on friend object.
    - Set it to zero when successfully sent. 
    x Look at the response code as well as the error state to determine whether to retry. 
      x Test non 200 response code
      x client failure.
    - Dont call completion function if we are going to retry.
    - If user relaunches app short circuit retry timer and add the tasks immediately.
    
    - Todo for retry 
       x Add field for retry count to friend
       x getRetryCountAsInt, setRetryCountWithInt
       x Set it to zero on successful upload
       x Change the state appropriately for 
         x new
         x uploading
         x retry
         x uploaded
       x Methods to handle retry
         x retry with friend (has timer)
         x cancel pending retries and restart them
     
     - Test retry
       x Continuous errors
       x A long upload that starts in the foreground but later fails in the background.
       x Retries going to long hold off in the background starting again immediately when you go to the foreground.

  - Background time for retry architecture
    - When doing a retry ask for background time if we havent asked for it before.
    - Dont end the background task even they call our expiration block because:
    // The apple docs say you must terminate the background task you requested when they call the expiration handler
    // or before or they will terminate your app. I have found however that if I dont terminate and if
    // the usage of the phone is low by other apps they will let us run in the background indefinitely
    // even after the backgroundTimeRemaining has long gone to 0. This is good for our users as it allows us
    // to continue retries in the background for a long time in the case of poor coverage.
     

QUESTION 
  What state does task go to when cancelled? 
  ANSWER: Have never seen canceled state. Probably transitions through so fast and then the task is removed.
  
TESTS   
   - New video for same user before original has finished uploading.
   - Phone in airplane mode.

NOTES:
   Note: NSURLSession does not report server errors through the error parameter. The only errors your delegate receives through the error parameter are client-side errors, such as being unable to resolve the hostname or connect to the host. The error codes are described in URL Loading System Error Codes.
   Server-side errors are reported through the HTTP status code in the NSHTTPURLResponse object. For more information, read the documentation for the NSHTTPURLResponse and NSURLResponse classes.


   Important: The session object keeps a strong reference to the delegate until your app explicitly invalidates the session. If you do not invalidate the session, your app leaks memory.


 - If server does not receive a file it should respond with an error.
 
 
 uploadTasksStates.friendId ||= {}
 
 NSMutableDictionary *states = [uploadTasksStates objectForKey:friendId];
 if (!states){
     states = [[NSMutableDictionary alloc] init];
     [uploadTasksState setObject:states forKey:friendId];
 }
 
 